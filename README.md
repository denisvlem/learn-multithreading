

1. **Основы многопоточности**
   
   - Что есть поток и что есть процесс и почему они разные?
    1. Процесс
       Каждая запущенная программа понимается операционной системой (ОС) как отдельный процесс. Запущенные браузер и редактор кода - два разных процесса. Любой из них ничего не знает о другом, но оба контролируются ОС. Каждому из процессов ОС выделяет свою собственную область в оперативной памяти, области эти не пересекаются. Иначе говоря процессы не имеют доступа к данным друг друга, иначе данные легко бы могли быть украдены или испорчены "соседним" процессом.
    2. Поток
       По отношению к процессу поток это сущность позволяющая использовать многоядерные процессоры для "распараллеливания" вычислений. То есть выполнять несколько задач одновременно, что позволяет получить преимущество в скорости. В одном процессе может работать множество потоков, а может и один.
    3. А разница?
       Потоки в отличие от процессов могут общаться через общую память, результаты работы одного потока доступны для другого. Потоки могут влиять на ход работы друг друга. Один поток может запускать, ставить на паузу и останавливать другой поток. Процессы тоже могут запускать и стопить друг друга (диспетчер задач в Windows для того и нужен), но разрешениями на такие действия ведает ОС. У процессов тоже есть способы обмениваться данными, но это работает иначе и совсем другая история.

   - Изучить, что такое Thread и Runnable, и как они используются для создания потоков.
     Способы создания Thread:
       1. Унаследоваться от класса Thread и имплементировать run()
       2. Имлементировать Runnable и передать в новый Thread
          У созданного thread вызвать метод `start()`
   - Знать методы жизненного цикла потоков: `start()`, `run()`, `sleep()`, `join()`, `interrupt()`.

2. **Синхронизация и блокировки**
    - Понять проблемы, связанные с многопоточностью, такие как состояние гонки и взаимная блокировка.
    - Изучить ключевое слово `synchronized` и его использование.
    - Разобраться с блокировками (Lock) и их различиями от синхронизированных методов/блоков.
    - Изучить классы из `java.util.concurrent.locks`, такие как `ReentrantLock`, `ReadWriteLock`.

3. **Высокоуровневые утилиты и структуры данных**
    - Разобраться с утилитами из пакета `java.util.concurrent`, такими как `Executor`, `ExecutorService`, `ScheduledExecutorService`.
    - Понять использование `Callable` и `Future`.
    - Изучить структуры данных для многопоточности: `ConcurrentHashMap`, `CopyOnWriteArrayList`, `BlockingQueue`.

4. **Синхронизаторы и барьеры**
    - Понять концепцию синхронизаторов и их использование.
    - Изучить классы `CountDownLatch`, `CyclicBarrier`, `Semaphore`, `Exchanger`.

5. **Пулы потоков (Thread Pools)**
    - Понять, что такое пул потоков и его преимущества.
    - Изучить классы `Executors` и методы для создания пулов потоков.
    - Разобраться в конфигурации и настройке пулов потоков для различных задач.

6. **Проблемы и отладка многопоточных приложений**
    - Изучить общие проблемы многопоточных приложений: взаимная блокировка, состояние гонки, ненадёжные публикации.
    - Понять методы и инструменты для отладки многопоточных приложений (например, использование VisualVM, JConsole).
    - Изучить основные шаблоны проектирования для многопоточности, такие как Producer-Consumer, Reader-Writer.

7. **Практические задачи**
    - Решать задачи на кодирование, связанные с многопоточностью.
    - Изучить и реализовать несколько примеров реальных приложений, где используются многопоточные конструкции.
    - Разобраться в написании тестов для многопоточных программ (использование `Thread.sleep()` для синхронизации тестов, библиотек для тестирования многопоточности).

8. **Обзор и повторение**
    - Повторить все ключевые концепции и убедиться в понимании теории.
    - Пройтись по основным вопросам, которые могут быть заданы на интервью.
    - Практиковаться в объяснении своих решений и подходов.